石博文
QQ：1311794174
email：shibw@tedu.cn

列表推导式
作用：用简单的方式生成列表
语法：[表达式 for 变量 in 可迭代对象] 或
[表达式 for 变量 in 可迭代对象 if 真值表达式]
>>> for i in l:
...     L.append(i**2)
...
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> L = [i**2 for i in l]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

练习：
1.生成1~9之间奇数的平方的列表
>>> L = [i**2 for i in range(1,10) if i % 2 == 1]
>>> L
[1, 9, 25, 49, 81]

2.输入一个开始的整数begin
输入一个结束的整数end
将从begin到end的所有的偶数存放到列表中
打印列表

列表推导式嵌套
L1 = [1,2,3]
L2 = [10,20,30]
将列表L1中的每一个元素分别与L2列表的每一个元素相加，将结果放到新列表L3

语法:[表达式 for 变量1 in 可迭代对象1 if 真值表达式1
     for 变量2 in 可迭代对象2 if 真值表达式2
     ... ...
]
 [x+y for x in L1 for y in L2]
>>> L3
[11, 21, 31, 12, 22, 32, 13, 23, 33]
>>> for x in L1:
...     for y in L2:
...         L4.append(x+y)

练习：
s = '100,200,600,800'
将字符串s转化成列表L 列表内全部为整数
求出列表L中所有数字的和


元组 tuple
定义:是一个不可改变的容器序列
表示方式：用小括号表示(),单个元素括起来之后加逗号区分

创建元组函数 tuple()
>>> t = tuple()
>>> t
()
>>> t = tuple("abc")
>>> t
('a', 'b', 'c')
>>> t = tuple([x**2 for x in range(1,10)])
>>> t
(1, 4, 9, 16, 25, 36, 49, 64, 81)
>>> t = tuple(range(1,10))
>>> t
(1, 2, 3, 4, 5, 6, 7, 8, 9)
休息10:35~10:55

元组运算
算数运算
+ += * *=
+用于拼接
*生成重复的元组
+=
*=

>>> t = (1,2,3)+(4,5,6)
>>> t
(1, 2, 3, 4, 5, 6)
>>> x = (1,2,3)
>>> x += (4,5,6)
>>> x
(1, 2, 3, 4, 5, 6)
>>> t = (1,2)
>>> t = (1,2) * 3
>>> t
(1, 2, 1, 2, 1, 2)
>>> t = (1,2)
>>> t *= 3
>>> t
(1, 2, 1, 2, 1, 2)


可变对象和不可变对象区别
列表：
L1 = [1,2,3]
L2 = L1
L2 += [4,5,6]
print(L2)#?L2 = [1,2,3,4,5,6]
print(L1)#?L1 = [1,2,3,4,5,6]

元组的比较运算
<  <= > >= == !=
同列表的比较规则

in/not in
同列表

元组的索引和切片
元组[整数]
元组[:]
元组[::]
规则同列表，元组不支持索引赋值和切片赋值

元组的方法：
tuple.index(v[,beigin[,end]])求对应元素的索引值
tuple.count(v)返回元组中对应元素的个数 元素不存在返回0

序列相关函数
len sum min max any all

序列的构造函数
str()
list()
tuple()

内建函数
reversed(可迭代对象)返回一个反向顺序的可迭代对象
sorted(可迭代对象,reverse=False)返回一个以排序的对象的列表


字典 dict
可变容器 可以存任意类型数据
字典中的每一个数据都是通过"键"索引
数据存储以键值对的方式映射存储 键:值
字典中的键通过哈希算法映射产生，哈希算法的目的是让数据更均匀的分布在字典中，这样字典中的数据没有先后顺序
字典的键不能重复，只能用不可变类型作为字典的键,字典的值可以为任意类型
不可变类型:str tuple 数字类型

创建字典
用{}表示 键和值以:分隔,键值对之间用逗号(,)分开

dict()字典的构造函数
dict() 创建空字典
dict(可迭代对象)
dict(**kwags)用关键字传参的方式创建字典

字典的基本操作
字典的索引
字典[键]
>>>d = dict(name='tarena',age=18)
{'age': 18, 'name': 'tarena'}
>>>d['name']
'tarena'
>>>d['age']
18

对字典的键赋值
字典[键] = 值
键存在 修改原来键的值
键不存在 创建一个新的键值对 添加到字典中

删除字典键值对
del 字典[键]

成员判断in /not in
判断键是否存在于字典中

练习：
键    值
1   春季有1,2,3月
2   夏季有4,5,6月
3   秋季有7,8,9月
4   冬季有10,11,12月
保存到字典中
让用户输入整数，打印对应的季度信息，如果用户输入的不在字典中，打印信息不存在

字典的迭代
字典是可迭代的 迭代的结果是字典的键
d = {'a':1,'b':2}
>>>for k in d:
...    print(k)
b
a
>>>for k in d:
...    print(d[k])
2
1

字典相关函数
len max min sum any all

字典的方法
字典.方法

练习
输入一段字符串 打印这个字符串中出现的字符以及字符出现的次数
如：ABCDABCABA
A:4
B:3
C:2
D:1

字典推导式
语法：
{键表达式:值表达式 for 变量 in 可迭代对象 if 真值表达式}

练习：
已知有两个等长列表L1和L2,生成相应的字典
L1 = [1001,1002,1003,1004]
L2 = ['Tom','Jerry','Alice','Bob']
生成的字典为
{'Tom':1001,....}

字典推导式嵌套
语法同列表推导式

字典 VS 列表
可变对象 可以保存任意数据类型
索引方式不同 列表使用整数按顺序索引
           字典按照键索引
列表有序 字典无序
字典的插入、修改、删除速度可能会快于列表


L = list(range(10))
for x in L:
    L.remove(x)
print(L) #?

集合 set
集合是可变的容器
集合的内容都是唯一的
集合是无序的
集合的元素必须是不可变的
集合就相当于只有键没有值的字典

创建集合
set()

集合的运算
交集&  并集|  补集- 对称补集^  子集<  超集>
休息：15:25~15:40
== != >= <=

in / not in

len max min sum any all

集合方法

集合推导式
{表达式 for 变量 in 可迭代对象 if 真值表达式}

集合推导式嵌套
同列表推导式

固定集合 frozenset
构造函数 frozenset()
不可变的 无序的 元素唯一的集合

阶段回顾
运算符
+ - * / // % **
< > <= >= == !=
is / is not
in / not in
not and or
短路逻辑
and 一假俱假
如果and前面的表达式为false，后面的表达式不再执行
or  一真俱真
如果or前面的表达式为True，后面的表达式不再执行
建议将耗时的代码判断放到后面

& | ^ #集合运算符

表达式
1
1 + 2
sum([1,2,3])+sum([4,5,6])
print()

条件表达式 x if x>y else y
所有推导式 列表 字典 集合

语句
input()
赋值语句 =
a = 100
a = b = c = 100
a,b,c = 100,200,300
删除语句 del 删除变量
if语句
pass语句
while语句
for语句
break语句
continue语句

内建函数
len max min sum any all

构造函数
bool int float complex str list tuple dict set frozenset

数值相关的函数
abs()
round()
pow()

字符串相关的函数
bin()
oct()
hex()
chr()
ord()

可迭代对象相关函数
range(start,end,step)
reversed()

对象和类型
type()
id()

help(__builtins__)







