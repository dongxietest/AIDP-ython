<!DOCTYPE html>
<html>
<head>
<title>waid1905_1720.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="%E3%80%8Adjango-%E6%95%99%E7%A8%8B%E3%80%8B">《Django 教程》</h1>
<ul>
<li>讲师: 魏明择</li>
<li>时间: 2019</li>
</ul>
<h2 id="%E7%9B%AE%E5%BD%95">目录</h2>
<p>[TOC]</p>
<!-- TOC depthFrom:2 depthTo:4 -->
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-object-oriented-programming">面向对象编程 Object-Oriented Programming</a>
<ul>
<li><a href="#class%E8%AF%AD%E5%8F%A5">class语句</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95instance-method">实例方法(instance method)</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7-attribute%E4%B9%9F%E5%8F%AB%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F">实例属性 attribute（也叫实例变量)</a></li>
<li><a href="#del-%E8%AF%AD%E5%8F%A5%E5%88%A0%E9%99%A4%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">del 语句删除实例属性</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">初始化方法</a></li>
<li><a href="#%E6%9E%90%E6%9E%84%E6%96%B9%E6%B3%95">析构方法</a></li>
<li><a href="#%E9%A2%84%E7%BD%AE%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">预置实例属性</a></li>
<li><a href="#%E7%94%A8%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0">用于类的函数</a></li>
<li><a href="#%E7%B1%BB%E5%B1%9E%E6%80%A7">类属性</a>
<ul>
<li><a href="#%E7%B1%BB%E7%9A%84%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2">类的文档字符串</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E7%9A%84-__slots__--%E5%88%97%E8%A1%A8">类的 <code>__slots__</code>  列表</a></li>
<li><a href="#%E7%B1%BB%E6%96%B9%E6%B3%95-classmethod">类方法 @classmethod</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-staticmethod">静态方法 @staticmethod</a></li>
</ul>
</li>
<li><a href="#%E7%BB%A7%E6%89%BFinheritance-%E5%92%8C-%E6%B4%BE%E7%94%9Fderived">继承(inheritance) 和 派生(derived)</a>
<ul>
<li><a href="#%E5%8D%95%E7%BB%A7%E6%89%BF">单继承</a></li>
<li><a href="#%E8%A6%86%E7%9B%96-override">覆盖 override</a></li>
<li><a href="#%E5%AD%90%E7%B1%BB%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95">子类显式调用基类的覆盖方法</a></li>
<li><a href="#super%E5%87%BD%E6%95%B0">super函数</a></li>
<li><a href="#%E7%94%A8%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0-1">用于类的函数</a></li>
</ul>
</li>
<li><a href="#%E5%B0%81%E8%A3%85-enclosure">封装 enclosure</a></li>
<li><a href="#%E5%A4%9A%E6%80%81-polymorphic">多态 polymorphic</a></li>
<li><a href="#%E5%A4%9A%E7%BB%A7%E6%89%BF-multiple-inheritance">多继承 multiple inheritance</a>
<ul>
<li><a href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84-mro-method-resolution-order-%E9%97%AE%E9%A2%98">多继承的 MRO (Method Resolution Order) 问题</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99overwrite">函数重写(overwrite)</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">对象转字符串函数重写</a></li>
<li><a href="#%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">内建函数重写</a></li>
<li><a href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">数值转换函数重写</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">布尔测试函数重写</a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%AB%98%E7%BA%A7">迭代器(高级)</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E9%AB%98%E7%BA%A7">异常(高级)</a>
<ul>
<li><a href="#with-%E8%AF%AD%E5%8F%A5">with 语句</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a>
<ul>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">算术运算符重载</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">反向算术运算符重载:</a></li>
<li><a href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">复合赋值算术运算符重载:</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">比较运算符的重载</a></li>
<li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">位运算符重载</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">反向位运算符重载</a></li>
<li><a href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">复合赋值位运算符重载</a></li>
<li><a href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">一元运算符重载</a></li>
<li><a href="#innot-in-%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">in/not in 成员运算符重载</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">索引和切片运算符重载:</a></li>
<li><a href="#slice%E5%87%BD%E6%95%B0">slice函数</a></li>
</ul>
</li>
<li><a href="#%E7%89%B9%E6%80%A7%E5%B1%9E%E6%80%A7-property">特性属性 @property</a></li>
<li><a href="#pep8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">PEP8编码规范</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E6%8E%92">代码编排</a></li>
<li><a href="#%E6%96%87%E6%A1%A3%E7%BC%96%E6%8E%92">文档编排</a></li>
<li><a href="#%E7%A9%BA%E6%A0%BC%E7%9A%84%E4%BD%BF%E7%94%A8">空格的使用</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-object-oriented-programming">面向对象编程 Object-Oriented Programming</h2>
<ul>
<li>
<p>什么是对象</p>
<ul>
<li>对象是指现实中的物体或实体</li>
</ul>
</li>
<li>
<p>什么是面向对象</p>
<ul>
<li>把一切看成对象（实例），用各种对象之间的关系来描述事务。</li>
</ul>
</li>
<li>
<p>对象都有什么特征</p>
<ul>
<li>对象有很多属性(名词)
<ul>
<li>姓名, 年龄, 性别,</li>
</ul>
</li>
<li>对象有很多行为(动作,动词)
<ul>
<li>学习,吃饭,睡觉,踢球, 工作</li>
</ul>
</li>
</ul>
</li>
<li>
<p>什么是类：</p>
<ul>
<li>拥有相同属性和行为的对象分为一组,即为一个类</li>
<li>类是用来描述对象的工具,用类可以创建此类的对象(实例)</li>
</ul>
</li>
<li>
<p>面向对象 示意</p>
<pre class="hljs"><code><div>车(类)  ------&gt;&gt; BYD  E6(京A.88888) 实例，对象
       \
        \.---&gt;&gt; BMW  X5(京B.00000) 实例(对象)

狗(类)  ------&gt;&gt; 小京巴(户籍号:000001)
       \
        \.---&gt;&gt; 导盲犬（户籍号:000002）

int(类)  ----&gt;&gt; 100 (对象)
        \
         \.--&gt;&gt; 200 (对象)
</div></code></pre>
</li>
</ul>
<h3 id="class%E8%AF%AD%E5%8F%A5">class语句</h3>
<ul>
<li>
<p>类的创建语句语法:</p>
<pre class="hljs"><code><div>class 类名 (继承列表):
    &quot;类文档字符串&quot;
    实例方法(类内的函数method) 定义
    类变量(class variable) 定义
    类方法(@classmethod) 定义
    静态方法(@staticmethod) 定义
</div></code></pre>
<blockquote>
<p>注: 继承列表可以省略，省略继承列表表示类继承自object.</p>
</blockquote>
</li>
<li>
<p>类的作用:</p>
<ul>
<li>创建一个类</li>
<li>类用于描述对象的行为和属性</li>
<li>类用于创建此类的一个或多个对象（实例）</li>
</ul>
</li>
<li>
<p>支持面向对象的语言:</p>
<ul>
<li>Python / C++/ C# / Java / Swift</li>
</ul>
</li>
<li>
<p>面向过程的语言</p>
<ul>
<li>C / Pascal / Delphi /Visual Basic</li>
</ul>
</li>
<li>
<p>类的创建示例</p>
<pre class="hljs"><code><div># file : class.py
class Dog:  # 定义一个Dog类
    pass
</div></code></pre>
</li>
<li>
<p>类的创建的说明:</p>
<ul>
<li>类名必须为标识符(与变量的命名相同,建议首字母大写)</li>
<li>类名实质上就是变量，它绑定一个类</li>
</ul>
</li>
<li>
<p>类和对象</p>
<table>
<thead>
<tr>
<th>类</th>
<th>对象</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>object</td>
<td>instance</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</h3>
<ul>
<li>
<p>构造函数调用表达式</p>
<pre class="hljs"><code><div>类名([创建传参列表])
</div></code></pre>
</li>
<li>
<p>构造函数作用</p>
<ul>
<li>创建这个类的实例对象，并返回此实例对象的引用关系</li>
</ul>
</li>
<li>
<p>用类创建对象示例：</p>
<pre class="hljs"><code><div># file : constructor.py
class Dog:
    pass

# 创建第一个实例：
dog1 = Dog()
print(id(dog1))  # 打印这个对象的ID
# 创建第二个实例对象
dog2 = Dog()  # dog2 绑定一个Dog类型的对象
print(id(dog2))

lst1 = list()
print(id(lst1))
lst2 = list()
print(id(lst2))
</div></code></pre>
</li>
<li>
<p>实例说明</p>
<ul>
<li>实例有自己的作用域和名字空间,可以为该实例添加实例变量（也叫属性)</li>
<li>实例可以调用类方法和实例方法</li>
<li>实例可以访问类变量和实例变量</li>
</ul>
</li>
</ul>
<h3 id="%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95instance-method">实例方法(instance method)</h3>
<pre><code>```
class 类名(继承列表):
    def 实例方法名(self, 参数1, 参数2, ...):
        &quot;文档字符串&quot;
        语句块
```
</code></pre>
<ul>
<li>
<p>实例方法的作用</p>
<ul>
<li>用于描述一个对象的行为,让此类型的全部对象都拥有相同的行为</li>
</ul>
</li>
<li>
<p>实例方法说明</p>
<ul>
<li>实例方法的实质是函数，是定义在类内的函数</li>
<li>实例方法至少有一个形参，第一个形参绑定调用这个方法的实例,一般命名为&quot;self&quot;</li>
<li>实例方法名是类属性</li>
</ul>
</li>
<li>
<p>实例方法的调用语法</p>
<pre class="hljs"><code><div>实例.实例方法名(调用传参)
# 或
类名.实例方法名(实例, 调用传参)
</div></code></pre>
</li>
<li>
<p>带有实例方法的简单的Dog类</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file: instance_method.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:</span>
    <span class="hljs-string">"""这是一个种小动物的定义
    这种动物是狗(犬)类，用于创建各种各样的小狗
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span><span class="hljs-params">(self, food)</span>:</span>
        <span class="hljs-string">'''此方法用来描述小狗吃东西的行为'''</span>
        print(<span class="hljs-string">"小狗正在吃"</span>, food)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sleep</span><span class="hljs-params">(self, hour)</span>:</span>
        print(<span class="hljs-string">"小狗睡了"</span>, hour, <span class="hljs-string">"小时!"</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">play</span><span class="hljs-params">(self, obj)</span>:</span>
        print(<span class="hljs-string">"小狗正在玩"</span>, obj)
</div></code></pre>
</li>
</ul>
<p>​<br>
dog1 = Dog()
dog1.eat(&quot;骨头&quot;)
dog1.sleep(1)
dog1.play('球')</p>
<pre><code>dog2 = Dog()
dog2.eat(&quot;窝头&quot;)
dog2.sleep(2)
dog2.play('飞盘')

&gt;&gt;&gt; help(Dog) # 可以看到Dog类的文档信息
```
</code></pre>
<h3 id="%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7-attribute%EF%BC%88%E4%B9%9F%E5%8F%AB%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F">实例属性 attribute（也叫实例变量)</h3>
<ul>
<li>
<p>每个实例可以有自己的变量，称为实例变量(也叫属性)</p>
</li>
<li>
<p>属性的使用语法</p>
<pre class="hljs"><code><div>实例.属性名
</div></code></pre>
</li>
<li>
<p>属性的赋值规则</p>
<ul>
<li>首次为属性赋值则创建此属性.</li>
<li>再次为属性赋值则改变属性的绑定关系.</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>记录每个对象自身的数据</li>
</ul>
</li>
<li>
<p>属性使用示例:</p>
<pre class="hljs"><code><div># file : attribute.py
class Dog:
    def eat(self, food):
         print(self.color, '的', self.kinds, '正在吃', food)
    pass
# 创建一个实例：
dog1 = Dog()
dog1.kinds = &quot;京巴&quot;  # 添加属性
dog1.color = &quot;白色&quot;
dog1.color = &quot;黄色&quot;  # 改变属性的绑定关系
print(dog1.color, '的', dog1.kinds)

dog2 = Dog()
dog2.kinds = &quot;藏獒&quot;
dog2.color = &quot;棕色&quot;
print(dog2.color, '的', dog2.kinds)
</div></code></pre>
</li>
<li>
<p>实例方法和实例属性(实例变量)结合在一起用:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span><span class="hljs-params">(self, food)</span>:</span>
        print(self.color, <span class="hljs-string">'的'</span>,
              self.kinds, <span class="hljs-string">'正在吃'</span>, food)


<span class="hljs-comment"># 创建第一个对象</span>
dog1 = Dog()
dog1.kinds = <span class="hljs-string">'京巴'</span>  <span class="hljs-comment"># 添加属性kinds</span>
dog1.color = <span class="hljs-string">'白色'</span>  <span class="hljs-comment"># 添加属性color</span>
<span class="hljs-comment"># print(dog1.color, '的', dog1.kinds)  # 访问属性</span>
dog1.eat(<span class="hljs-string">"骨头"</span>)

dog2 = Dog()
dog2.kinds = <span class="hljs-string">'牧羊犬'</span>
dog2.color = <span class="hljs-string">'灰色'</span>
<span class="hljs-comment"># print(dog2.color, '的', dog2.kinds)  # 访问属性</span>
dog2.eat(<span class="hljs-string">'包子'</span>)
</div></code></pre>
</li>
<li>
<p>练习:</p>
<ul>
<li>定义一个'人'类:<pre class="hljs"><code><div>class Human:
    def set_info(self, name, age, address='不详'):
        '''此方法用来给人对象添加'姓名'、'年龄'和 '家庭住址' 属性
        # 此处自己实现
    def show_info(self):
        '''此处显示此人的信息'''
        # 此处自己实现

# 如:
s1 = Human()
s1.set_info('小张', 20, '北京市朝阳区')
s2 = Human()
s2.set_info('小李', 18)``
s1.show_info()  # 小张 今年 20 岁, 家庭住址: 北京市朝阳区
s2.show_info()  # 小李 今年 18 岁, 家庭住址: 不详
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>day17 pm</p>
</li>
</ul>
<h3 id="del-%E8%AF%AD%E5%8F%A5%E5%88%A0%E9%99%A4%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">del 语句删除实例属性</h3>
<pre><code>```
del 对象.实例属性名
```
</code></pre>
<ul>
<li>del 语句 最终总结:
<ol>
<li>删除变量</li>
<li>删除列表中的元素</li>
<li>删除字典中的键值对</li>
<li>删除对象的属性(也叫实例变量)</li>
</ol>
</li>
</ul>
<h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95">初始化方法</h3>
<ul>
<li>
<p>初始化方法的作用：</p>
<ul>
<li>对新创建的对象添加属性</li>
</ul>
</li>
<li>
<p>初始化方法的语法格式：</p>
<pre class="hljs"><code><div>class 类名(继承列表):
    def __init__(self[, 形参列表]):
        语句块
# [] 代表其中的内容可省略
</div></code></pre>
</li>
<li>
<p>初始化方法的说明：</p>
<ul>
<li>初始化方法名必须为<code>__init__</code> 不可改变</li>
<li>初始化方法会在构造函数创建实例后自动调用,且将实例自身通过第一个参数self传入<code>__init__</code>方法</li>
<li>构造函数的实参将通过<code>__init__</code>方法的 参数列表 传入到 <code>__init__</code>方法中</li>
<li>初始化方法内如果需要return语句返回，则必须返回None</li>
</ul>
</li>
<li>
<p>初始化方法示例：</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : init_method.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, c, b, m)</span>:</span>
        self.color = c  <span class="hljs-comment"># 颜色</span>
        self.brand = b  <span class="hljs-comment"># 品牌</span>
        self.model = m  <span class="hljs-comment"># 型号</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self, speed)</span>:</span>
        print(self.color, <span class="hljs-string">"的"</span>, self.brand, self.model, <span class="hljs-string">"正在以"</span>, speed, <span class="hljs-string">"公里／小时的速度行驶"</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_color</span><span class="hljs-params">(self, c)</span>:</span>
        self.color = c

a4 = Car(<span class="hljs-string">"红色"</span>, <span class="hljs-string">"奥迪"</span>, <span class="hljs-string">"A4"</span>)
a4.run(<span class="hljs-number">199</span>)
a4.change_color(<span class="hljs-string">"黑色"</span>)
a4.run(<span class="hljs-number">230</span>)
</div></code></pre>
</li>
</ul>
<h3 id="%E6%9E%90%E6%9E%84%E6%96%B9%E6%B3%95">析构方法</h3>
<ul>
<li>
<p>语法格式</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXX</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span><span class="hljs-params">(self)</span>:</span>
        ...
</div></code></pre>
</li>
<li>
<p>说明:</p>
<ul>
<li>析构函数在对象被销毁时被自动调用</li>
<li>python语言建议不要在对象销毁时做任何事情,因为销毁的时间难以确定</li>
</ul>
</li>
<li>
<p>析构方法示例</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : del_method.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
        self.name = name
        print(<span class="hljs-string">"汽车"</span>, name, <span class="hljs-string">"对象已创建!"</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"汽车"</span>, self.name, <span class="hljs-string">"对象已销毁"</span>)

c1 = Car(<span class="hljs-string">"BYD E6"</span>)
<span class="hljs-keyword">del</span> c1
</div></code></pre>
</li>
</ul>
<h3 id="%E9%A2%84%E7%BD%AE%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">预置实例属性</h3>
<ul>
<li>
<p><code>__dict__</code> 属性</p>
<ul>
<li>用于绑定一个存储此实例自身属性的字典</li>
<li><code>__dict__</code> 属性示例：<pre class="hljs"><code><div>class Dog:
    pass

dog1 = Dog()
print(dog1.__dict__)
dog1.kinds = &quot;京巴&quot;
print(dog1.__dict__)
dog1.color = &quot;白色&quot;
print(dog1.__dict__)
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><code>__class__</code> 属性</p>
<ul>
<li>
<p><code>__class__</code> 属性绑定创建此实例的类</p>
</li>
<li>
<p><code>__class__</code> 属性作用</p>
<ul>
<li>可以借助于此属性来访问创建此实例的类</li>
</ul>
</li>
<li>
<p>示例：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:</span>
    <span class="hljs-keyword">pass</span>

dog1 = Dog()
print(dog1.__class__)
dog2 = dog1.__class__()
print(dog2.__class__)
</div></code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="%E7%94%A8%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0">用于类的函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>isinstance(obj, class_or_tuple)</td>
<td>返回这个对象obj 是否是 某个类的对象,或者某些类<br>中的一个类的对象,如果是返回True,否则返回False</td>
</tr>
<tr>
<td>type(obj)</td>
<td>返回对象的类型</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>day18</li>
</ul>
<h3 id="%E7%B1%BB%E5%B1%9E%E6%80%A7">类属性</h3>
<ul>
<li>
<p>类属性是类的属性，此属性属于类，不属于此类的实例</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>通常用来存储该类创建的对象的共有属性</li>
</ul>
</li>
<li>
<p>类属性说明</p>
<ul>
<li>类属性,可以通过该类直接访问</li>
<li>类属性,可以通过类的实例直接访问</li>
<li>类属性可以通过此类的对象的<code>__class__</code>属性间接访问</li>
</ul>
</li>
<li>
<p>类属性示例</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : class_attribute.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span>:</span>
    total_count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 创建类属性</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
        self.name = name
        self.__class__.total_count += <span class="hljs-number">1</span>

print(Human.total_count)
h1 = Human(<span class="hljs-string">"小张"</span>)
print(h1.total_count)
</div></code></pre>
</li>
</ul>
<h4 id="%E7%B1%BB%E7%9A%84%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2">类的文档字符串</h4>
<ul>
<li>
<p>类内第一个没有赋值给任何变量的字符串为类的文档字符串</p>
</li>
<li>
<p>类的文档字符串可以通过help函数查看</p>
</li>
<li>
<p>类的文档字符串可以用 类的 <code>__doc__</code> 属性访问</p>
</li>
<li>
<p>类的文档字符串示例:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:</span>
    <span class="hljs-string">"""Dog类的文档字符串
    此文档字符串用于描述类的信息"""</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>help(Dog)  <span class="hljs-comment"># 查看上述文档字符串</span>
</div></code></pre>
</li>
</ul>
<h3 id="%E7%B1%BB%E7%9A%84-slots-%E5%88%97%E8%A1%A8">类的 <code>__slots__</code>  列表</h3>
<ul>
<li>
<p>作用：</p>
<ul>
<li>限定一个类创建的实例只能有固定的实例属性(实例变量)</li>
<li>不允许对象添加列表以外的实例属性(实例变量)</li>
<li>防止用户因错写属性的名称而发生程序错误。</li>
</ul>
</li>
<li>
<p>说明：</p>
<ul>
<li><code>__slots__</code> 属性是一个列表，列表的值是字符串</li>
<li>含有<code>__slots__</code>属性的类所创建的实例对象没有<code>__dict__</code>属性, 即此实例不用字典来存储对象的实例属性（实例变量）</li>
</ul>
</li>
<li>
<p>示例</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span>:</span>
    __slots__ = [<span class="hljs-string">"name"</span>, <span class="hljs-string">"age"</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
        self.name, self.age = name, age
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_info</span><span class="hljs-params">(self)</span>:</span>
        print(self.name, self.age)

h1 = Human(<span class="hljs-string">"Tarena"</span>, <span class="hljs-number">15</span>)
h1.show_info()
h1.Age = <span class="hljs-number">16</span>
h1.show_info()
print(h1.age)
h1.Age = <span class="hljs-number">100</span>  <span class="hljs-comment"># 出错，s1对象没有Age属性</span>
</div></code></pre>
</li>
</ul>
<h3 id="%E7%B1%BB%E6%96%B9%E6%B3%95-classmethod">类方法 @classmethod</h3>
<ul>
<li>
<p>类方法是用于描述类的行为的方法，类方法属于类，不属于该类创建的对象</p>
</li>
<li>
<p>说明</p>
<ul>
<li>类方法需要使用@classmethod装饰器定义</li>
<li>类方法至少有一个形参，第一个形参用于绑定类，约定写为'cls'</li>
<li>类和该类的实例都可以调用类方法</li>
<li>类方法不能访问此类创建的对象的实例属性</li>
</ul>
</li>
<li>
<p>类方法示例</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    v = <span class="hljs-number">0</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_v</span><span class="hljs-params">(cls, value)</span>:</span>
        cls.v = value
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_v</span><span class="hljs-params">(cls)</span>:</span>
        <span class="hljs-keyword">return</span> cls.v
print(A.get_v())
A.set_v(<span class="hljs-number">100</span>)
print(A.get_v)
a = A()
print(A.get_v())
</div></code></pre>
</li>
</ul>
<h3 id="%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-staticmethod">静态方法 @staticmethod</h3>
<ul>
<li>
<p>静态方法是定义在类的内部函数，此函数的作用域是类的内部</p>
</li>
<li>
<p>说明</p>
<ul>
<li>静态方法需要使用@staticmethod装饰器定义</li>
<li>静态方法与普通函数定义相同，不需要传入self实例参数和cls类参数</li>
<li>静态方法只能凭借该类或类创建的实例调用</li>
<li>静态方法不能访问类属性和实例属性</li>
</ul>
</li>
<li>
<p>静态方法示例</p>
<pre class="hljs"><code><div>class A:
    @staticmethod
    def myadd(a, b):
        return a+b

print(A.myadd(100, 200))
a = A()
print(a.myadd(300, 400))
</div></code></pre>
</li>
<li>
<p>day18 pm</p>
</li>
</ul>
<h2 id="%E7%BB%A7%E6%89%BFinheritance-%E5%92%8C-%E6%B4%BE%E7%94%9Fderived">继承(inheritance) 和 派生(derived)</h2>
<ul>
<li>
<p>什么是继承／派生</p>
<ul>
<li>继承是从已有的类中派生出新的类，新类具有原类的数据属性和行为，并能扩展新的能力。</li>
<li>派生类就是从一个已有类中衍生出新类，在新的类上可以添加新的属性和行为</li>
</ul>
</li>
<li>
<p>为什么继承/派生</p>
<ul>
<li>继承的目的是延续旧的类的功能</li>
<li>派生的目地是在旧类的基础上添加新的功能</li>
</ul>
</li>
<li>
<p>继承/派生的作用</p>
<ul>
<li>用继承派生机制，可以将一些共有功能加在基类中。实现代码的共享。</li>
<li>在不改变基类的代码的基础上改变原有类的功能</li>
</ul>
</li>
<li>
<p>继承/派生名词：</p>
<ul>
<li>基类(base class)/超类(super class)/父类(father class)</li>
<li>派生类(derived class)/子类(child class)</li>
</ul>
</li>
</ul>
<h3 id="%E5%8D%95%E7%BB%A7%E6%89%BF">单继承</h3>
<ul>
<li>
<p>单继承的语法:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> 类名<span class="hljs-params">(基类名)</span>:</span>
    语句块
</div></code></pre>
</li>
<li>
<p>单继承说明:</p>
<ul>
<li>单继承是指派生类由一个基类衍生出来的</li>
</ul>
</li>
<li>
<p>单继承的示例1:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span>:</span>  <span class="hljs-comment"># 人类的共性</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span><span class="hljs-params">(self, what)</span>:</span>  <span class="hljs-comment"># 说话</span>
        print(<span class="hljs-string">"说："</span>, what)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">walk</span><span class="hljs-params">(self, distance)</span>:</span>  <span class="hljs-comment"># 走路</span>
        print(<span class="hljs-string">"走了"</span>, distance, <span class="hljs-string">"公里"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(Human)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">study</span><span class="hljs-params">(self, subject)</span>:</span>  <span class="hljs-comment"># 学习</span>
        print(<span class="hljs-string">"学习:"</span>, subject)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span><span class="hljs-params">(Human)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teach</span><span class="hljs-params">(self, language)</span>:</span>
        print(<span class="hljs-string">"教:"</span>, language)

h1 = Human()
h1.say(<span class="hljs-string">"天气真好!"</span>)
h1.walk(<span class="hljs-number">5</span>)

s1 = Student()
s1.walk(<span class="hljs-number">4</span>)
s1.say(<span class="hljs-string">"感觉有点累"</span>)
s1.study(<span class="hljs-string">"python"</span>)

t1 = Teacher()
t1.teach(<span class="hljs-string">"面向对象"</span>)
t1.walk(<span class="hljs-number">6</span>)
t1.say(<span class="hljs-string">"一会吃点什么好呢"</span>)
```py



</div></code></pre>
</li>
<li>
<p>继承说明：</p>
<ul>
<li>Python3任何类都直接或间接的继承自object类</li>
<li>object类是一切类的超类</li>
</ul>
</li>
<li>
<p>类的 <code>__base__</code> 属性(在继承之后讲)</p>
<ul>
<li><code>__base__</code>属性用来记录此类的基类</li>
<li>详见 ：<code>&gt;&gt;&gt; help(__builtins__)</code></li>
</ul>
</li>
</ul>
<h3 id="%E8%A6%86%E7%9B%96-override">覆盖 override</h3>
<ul>
<li>
<p>覆盖是指在有继承关系的类中，子类中实现了与基类同名的方法,在子类的实例调用该方法时，实际调用的是子类中的覆盖版本,这种现象叫覆盖</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>实现和父类同名，但功能不同的方法</li>
</ul>
</li>
<li>
<p>覆盖示例</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : override.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"A.work 被调用!"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-params">(A)</span>:</span>
    <span class="hljs-string">'''B类继承自A类'''</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"B.work 被调用!!!"</span>)
    <span class="hljs-keyword">pass</span>

b = B()
b.work()  <span class="hljs-comment"># 请问调用谁?  B</span>

a = A()
a.work()  <span class="hljs-comment"># 请问调用谁?  A</span>
</div></code></pre>
</li>
</ul>
<h3 id="%E5%AD%90%E7%B1%BB%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95">子类显式调用基类的覆盖方法</h3>
<ul>
<li>
<p>问题?</p>
<ul>
<li>当在覆盖发生时，子类对象能否调用父类中的方法?</li>
</ul>
</li>
<li>
<p>子类对象显式调用基类方法的方式：</p>
<ul>
<li>基类名.方法名(实例，实际调用参数, ...)</li>
</ul>
</li>
</ul>
<h3 id="super%E5%87%BD%E6%95%B0">super函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>super(cls, obj)</td>
<td>返回绑定超类的实例(要求obj必须为cls类型的实例)</td>
</tr>
<tr>
<td>super()</td>
<td>返回绑定超类的实例,等同于:super(<strong>class</strong>, 实例方法的第一个参数)，必须用在方法内调用</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>super函数 作用</p>
<ul>
<li>借助super() 返回的实例间接调用其父类的覆盖方法</li>
</ul>
</li>
<li>
<p>super函数 示例：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"A类的work被调用"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-params">(A)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"B类的work被调用"</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">super_work</span><span class="hljs-params">(self)</span>:</span>
        self.work(). <span class="hljs-comment"># 调用自身的work 方法</span>
        <span class="hljs-comment"># 以下两种方式来调用父类的方法</span>
        super(B, self).work()
        super().work()

b = B()
<span class="hljs-comment"># b.work() # 调用子类方法，但没办法调用超类方法</span>
super(B, b).work()  <span class="hljs-comment"># 调用超类方法</span>
b.super_work()
</div></code></pre>
</li>
<li>
<p>显式调用基类的初始化方法:</p>
<pre class="hljs"><code><div># 当子类中实现了__init__ 方法，基类的初始化方法并不会被调用.
def __init__(self, ....):
    ....
</div></code></pre>
</li>
<li>
<p>显示调用基类的初始化方法示例</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : super_init.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n, a)</span>:</span>
        self.name, self.age = n, a
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">infos</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"姓名:"</span>, self.name)
        print(<span class="hljs-string">"年龄:"</span>, self.age)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><span class="hljs-params">(Human)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n, a, s=<span class="hljs-number">0</span>)</span>:</span>
        super().__init__(n,a)
        self.score = s
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">infos</span><span class="hljs-params">(self)</span>:</span>
        super().infos()
        print(<span class="hljs-string">"成绩:"</span>, self.score)

s = Student(<span class="hljs-string">"wei"</span>, <span class="hljs-number">35</span>, <span class="hljs-number">100</span>)
</div></code></pre>
</li>
<li>
<p>day19</p>
</li>
</ul>
<h3 id="%E7%94%A8%E4%BA%8E%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0">用于类的函数</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>issubclass(cls, class_or_tuple)</td>
<td>判断一个类是否继承自其它的类,如果此类cls是class 或 tuple中的一个派生子类则返回True,否则返回False</td>
</tr>
</tbody>
</table>
<ul>
<li>issubclass 示例：<pre class="hljs"><code><div><span class="hljs-comment"># file : issubclass.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span> <span class="hljs-keyword">pass</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-params">(A)</span>:</span> <span class="hljs-keyword">pass</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span><span class="hljs-params">(B)</span>:</span> <span class="hljs-keyword">pass</span>

issubclass(C, (A, B))  <span class="hljs-comment"># True</span>
issubclass(C, (int, str))  <span class="hljs-comment"># False</span>
issubclass(D, (int, A))    <span class="hljs-comment"># True</span>
</div></code></pre>
</li>
</ul>
<h2 id="%E5%B0%81%E8%A3%85-enclosure">封装 enclosure</h2>
<ul>
<li>
<p>封装是指隐藏类的实现细节，让使用者不用关心这些细节;</p>
</li>
<li>
<p>封装的目的是让使用者通过尽可能少的方法(或属性)操作对象</p>
</li>
<li>
<p>Python的封装是假的（模拟的）封装</p>
</li>
<li>
<p>私有属性和方法</p>
<ul>
<li>python类中以双下划线(<code>__</code>)开头，不以双下划线结尾的标识符为私有成员,私有成员只能使用方法来进行访问和修改
<ul>
<li>以<code>__</code>开头的属性为类的私有属性，在子类和类外部无法直接使用</li>
<li>以<code>__</code>开头的方法为私有方法，在子类和类外部无法直接调用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>私有属性和方法 示例：</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : enclosure.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.__p1 = <span class="hljs-number">100</span>  <span class="hljs-comment"># 私有属性</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__m1</span><span class="hljs-params">(self)</span>:</span>  <span class="hljs-comment"># 私有方法</span>
        print(<span class="hljs-string">"__m1(self) 方法被调用"</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showA</span><span class="hljs-params">(self)</span>:</span>
        self.__m1()
        print(<span class="hljs-string">"self.__p1 = "</span>, self.__p1)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-params">(A)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        super().__init__()
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showB</span><span class="hljs-params">(self)</span>:</span>
        self.__m1()  <span class="hljs-comment"># 出错，不允许调用</span>
        print(<span class="hljs-string">"self.__p1 = "</span>, self.__p1)  <span class="hljs-comment"># 出错，不允许调用</span>

a = A()
a.showA()
a.__m1()       <span class="hljs-comment"># 出错，不允许调用</span>
v = self.__p1  <span class="hljs-comment"># 出错，不允许调用</span>
b = B()
b.showB()
</div></code></pre>
</li>
</ul>
<h2 id="%E5%A4%9A%E6%80%81-polymorphic">多态 polymorphic</h2>
<ul>
<li>
<p>什么是多态:</p>
<ul>
<li>字面意思&quot;多种状态&quot;</li>
<li>多态是指在有继承/派生关系的类中，调用基类对象的方法,实际能调用子类的覆盖方法的现象叫多态</li>
</ul>
</li>
<li>
<p>状态：</p>
<ul>
<li>静态(编译时状态)</li>
<li>动态(运行时状态)</li>
</ul>
</li>
<li>
<p>多态说明：</p>
<ul>
<li>多态调用的方法与对象相关，不与类型相关</li>
<li>Python的全部对象都只有&quot;运行时状态(动态)&quot;, 没有&quot;C++语言&quot;里的&quot;编译时状态(静态)&quot;</li>
</ul>
</li>
<li>
<p>多态示例：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"Shape的draw()被调用"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span><span class="hljs-params">(Shape)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"正在画一个点!"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><span class="hljs-params">(Point)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"正在画一个圆!"</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_draw</span><span class="hljs-params">(s)</span>:</span>
    s.draw()  <span class="hljs-comment"># 此处显示出多态</span>

shapes1 = Circle()
shapes2 = Point()
my_draw(shapes1)  <span class="hljs-comment"># 调用Circle 类中的draw</span>
my_draw(shapes2)  <span class="hljs-comment"># Point 类中的draw</span>
</div></code></pre>
</li>
<li>
<p>面向对象编程语言的特征:</p>
<ul>
<li>继承</li>
<li>封装</li>
<li>多态</li>
</ul>
</li>
</ul>
<h2 id="%E5%A4%9A%E7%BB%A7%E6%89%BF-multiple-inheritance">多继承 multiple inheritance</h2>
<ul>
<li>
<p>多继承是指一个子类继承自两个或两个以上的基类</p>
</li>
<li>
<p>多继承的语法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> 类名<span class="hljs-params">(基类名<span class="hljs-number">1</span>, 基类名<span class="hljs-number">2</span>[, ...])</span>:</span>
    ...
</div></code></pre>
</li>
<li>
<p>多继承说明</p>
<ul>
<li>一个子类同时继承自多个父类，父类中的方法可以同时被继承下来</li>
<li>如果两个父类中有同名的方法，而在子类中又没有覆盖此方法时，调用结果难以确定</li>
</ul>
</li>
<li>
<p>多继承的示例：</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : multiple_inherit.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self, speed)</span>:</span>
        print(<span class="hljs-string">"汽车以"</span>, speed, <span class="hljs-string">"km/h的速度行驶"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plane</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fly</span><span class="hljs-params">(self, height)</span>:</span>
        print(<span class="hljs-string">"飞行以海拔"</span>, height, <span class="hljs-string">"米的高度飞行"</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlaneCar</span><span class="hljs-params">(Car, Plane)</span>:</span>
    <span class="hljs-string">"""PlaneCar类 ，同时继承自汽车和飞机"""</span>

p1 = PlaneCar()
p1.fly(<span class="hljs-number">10000</span>)
p1.run(<span class="hljs-number">300</span>)
</div></code></pre>
</li>
<li>
<p>多继承的问题(缺陷)：</p>
<ul>
<li>标识符(名字空间)冲突的问题</li>
<li>要谨慎使用多继承</li>
</ul>
</li>
</ul>
<h3 id="%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84-mro-method-resolution-order-%E9%97%AE%E9%A2%98">多继承的 MRO (Method Resolution Order) 问题</h3>
<ul>
<li>
<p>类的<code>__mro__</code>属性</p>
<ul>
<li>用来记录类的方法查找顺序</li>
</ul>
</li>
<li>
<p>示例:</p>
<pre class="hljs"><code><div>class A:
    def go(self):
        print(&quot;A&quot;)
class B(A):
    def go(self):
        print(&quot;B&quot;)
class C(A):
    def go(self):
        print(&quot;C&quot;)
class D(B,C):
    def go(self):
        print(&quot;D&quot;)
print(D.__mro__) # (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)
</div></code></pre>
</li>
<li>
<p>钻石继承:</p>
<pre class="hljs"><code><div>   A
  / \
 /   \
B     C
 \   /
  \ /
   D
</div></code></pre>
</li>
<li>
<p>day19 pm</p>
</li>
</ul>
<h2 id="%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99overwrite">函数重写(overwrite)</h2>
<ul>
<li>在自定义类内添加相应的方法,让自定义类创建的实例像内建对象一样进行内建函数操作</li>
</ul>
<h3 id="%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">对象转字符串函数重写</h3>
<pre><code>- repr 返回一个附合Python语法规则且能代表此对象的表达式字符串, 通常:
    - eval(repr(obj)) == obj
- str(obj) 通过给定的对象返回一个字符串(这个字符串通常是给人阅读的)

&gt; 注：repr(obj) 函数和str(obj)函数都是返回一个对象的字符串
</code></pre>
<ul>
<li>
<p>对象转字符串函数重写方法</p>
<ul>
<li>repr() 函数的重载方法:
<ul>
<li><code>def __repr__(self)</code></li>
</ul>
</li>
<li>str() 函数的重载方法:
<ul>
<li><code>def __str__(self)</code>
<ul>
<li>如果没有 <code>__str__(self)</code> 方法，则返回repr(obj)函数结果代替</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>str(obj)函数调用方法说明</p>
<ol>
<li>str(obj)函数先查找obj.<strong>str</strong>() 方法,调用此方法并返回结果</li>
<li>如果<code>obj.__str()__</code>方法不存在，则调用<code>obj.__repr__</code>方法并返回结果</li>
<li>如果<code>obj.__repr__</code>方法不存在，则调用object类的<code>__repr__</code>实例方法显示'&lt;<strong>main</strong>.MyNumber object at 0x102a8ea20&gt;'格式的字符串</li>
</ol>
</li>
<li>
<p>str/repr函数重写示例</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : mynumber.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNumber</span>:</span>
    <span class="hljs-string">"此类用于定义一个自定义的类，用于演示str/repr函数重写"</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        <span class="hljs-string">"构造函数,初始化MyNumber对象"</span>
        self.data = value
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">"转换为eval能够识别的字符串"</span>
        print(<span class="hljs-string">'__repr__(self)方法被调用 '</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyNumber(%d)"</span> % self.data

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">"转换为普通字符串"</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"%d"</span> % self.data

n1 = MyNumber(<span class="hljs-number">100</span>)
n2 = MyNumber(<span class="hljs-number">200</span>)
print(<span class="hljs-string">"repr(n1) ===&gt;"</span>, repr(n1)
print(<span class="hljs-string">"str(n2) ===&gt;"</span>, str(n2))
</div></code></pre>
</li>
</ul>
<h3 id="%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">内建函数重写</h3>
<ul>
<li>
<p><code>__abs__</code>        abs(obj) 函数调用</p>
</li>
<li>
<p><code>__len__</code>        len(obj) 函数调用</p>
</li>
<li>
<p><code>__reversed__</code>   reversed(obj) 函数调用</p>
</li>
<li>
<p><code>__round__</code>      round(obj) 函数调用</p>
</li>
<li>
<p>内建函数 重写示例</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : len_overwrite.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, iterable=<span class="hljs-params">()</span>)</span>:</span>
        self.data = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> iterable]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr_</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyList(%s)"</span> % self.data
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"__len__(self) 被调用!"</span>)
        <span class="hljs-keyword">return</span> len(self.data)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__abs__</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"__len__(self) 被调用!"</span>)
        <span class="hljs-keyword">return</span> MyList((abs(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.data))

myl = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-4</span>])
print(len(myl))
print(abs(myl))
</div></code></pre>
</li>
</ul>
<h3 id="%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">数值转换函数重写</h3>
<ul>
<li>
<p><code>__complex__</code>    complex(obj) 函数调用</p>
</li>
<li>
<p><code>__int__</code>        int(obj) 函数调用</p>
</li>
<li>
<p><code>__float__</code>      float(obj) 函数调用</p>
</li>
<li>
<p><code>__bool__</code>       bool(obj) 函数调用(稍后会讲)</p>
</li>
<li>
<p>数值转换函数重写示例</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNumber</span>:</span>
    <span class="hljs-string">"此类用于定义一个自定义的类，用于演示函数重写"</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        <span class="hljs-string">"构造函数,初始化MyNumber对象"</span>
        self.data = value
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__float__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">"float函数重写"</span>
        print(<span class="hljs-string">"__float__ is called"</span>)
        <span class="hljs-keyword">return</span> float(self.data)

n1 = MyNumber(<span class="hljs-string">'100'</span>)
print(float(n1))
</div></code></pre>
</li>
</ul>
<h3 id="%E5%B8%83%E5%B0%94%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99">布尔测试函数重写</h3>
<ul>
<li>
<p>布尔测试函数重写 格式</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bool__</span><span class="hljs-params">(self)</span>:</span>
    ...
</div></code></pre>
</li>
<li>
<p>作用:</p>
<ul>
<li>用于bool(obj)函数取值</li>
<li>用于if语句真值表达式中</li>
<li>用于while语句真值表达式中</li>
</ul>
</li>
<li>
<p>布尔测试函数重写说明：</p>
<ul>
<li>当自定义类内有<code>__bool__(self)</code>方法时,以此方法的返回值作为bool(obj)的返回值</li>
<li>当不存在__bool__(self)方法时,bool(x)返回__len__(self)方法的返回值是否为零来测试布尔值</li>
<li>当不存在__len__(self)方法时，则直接返回True</li>
</ul>
</li>
<li>
<p>布尔测试函数重写示例:  ( 将此示例上调至 abs. len 方法重写)</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : bool.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, iterable=<span class="hljs-params">()</span>)</span>:</span>
        self.data = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> iterable]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyList(%s)"</span> % self.data
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bool__</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"__bool__(self) 被调用!"</span>)
        <span class="hljs-keyword">return</span> any(self.data)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"__len__(self) 被调用!"</span>)
        <span class="hljs-keyword">return</span> len(self.data)
    <span class="hljs-comment"># def __abs__(self):</span>
    <span class="hljs-comment">#     print("__len__(self) 被调用!")</span>
    <span class="hljs-comment">#     return MyList((abs(x) for x in self.data))</span>


myl = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-4</span>])
print(len(myl))
<span class="hljs-comment"># print(abs(myl))</span>
<span class="hljs-keyword">if</span> myl:
    print(<span class="hljs-string">"myl为真值"</span>)
<span class="hljs-keyword">else</span>:
    print(<span class="hljs-string">"myl为假值"</span>)

myl = MyList(count = <span class="hljs-number">10</span>, value = <span class="hljs-number">1</span>)
<span class="hljs-keyword">if</span> myl:
    print(<span class="hljs-string">"myl为真值"</span>)
<span class="hljs-keyword">else</span>:
    print(<span class="hljs-string">"myl为假值"</span>)
</div></code></pre>
</li>
<li>
<p>对象的属性管理函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getattr(obj, name[, default])</td>
<td>从一个对象得到对象的属性；getattr(x, 'y') 等同于x.y; 当属性不存在时,如果给<br>出default参数,则返回default,如果没有给出default 则产生一个AttributeError错误</td>
</tr>
<tr>
<td>hasattr(obj, name)</td>
<td>用给定的name返回对象obj是否有此属性,此种做法可以避免在getattr(obj, name)时引发错误</td>
</tr>
<tr>
<td>setattr(obj, name, value)</td>
<td>给对象obj的名为name的属性设置相应的值value, setattr(x, 'y', v) 等同于 x.y = v</td>
</tr>
<tr>
<td>delattr(obj, name)</td>
<td>删除对象obj中的name属性, delattr(x, 'y') 等同于 del x.y</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>对象的属性管理函数示例:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:</span>
    <span class="hljs-keyword">pass</span>
d = Dog()
d.color = <span class="hljs-string">'白色'</span>
v = getattr(d, <span class="hljs-string">'color'</span>)   <span class="hljs-comment"># 等同于 v = d.color</span>
v = getattr(d, <span class="hljs-string">'kinds'</span>)  <span class="hljs-comment"># 出错,没有d.kinds属性</span>
v = getattr(d, <span class="hljs-string">'kinds'</span>, <span class="hljs-string">'没有这个属性'</span>)  <span class="hljs-comment"># v= '没有这个属性'</span>
hasattr(d, <span class="hljs-string">'color'</span>)  <span class="hljs-comment"># True</span>
hasattr(d, <span class="hljs-string">'kinds'</span>)  <span class="hljs-comment"># False</span>
setattr(d, <span class="hljs-string">'kinds'</span>, <span class="hljs-string">'京巴'</span>)  <span class="hljs-comment"># 等同于d.kinds ='京巴'</span>
hasattr(d, <span class="hljs-string">'kinds'</span>)  <span class="hljs-comment"># True</span>
delattr(d, <span class="hljs-string">'kinds'</span>)  <span class="hljs-comment"># 等同于 del d.kinds</span>
hasattr(d, <span class="hljs-string">'kinds'</span>)  <span class="hljs-comment"># False</span>
</div></code></pre>
</li>
</ul>
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%AB%98%E7%BA%A7">迭代器(高级)</h2>
<ul>
<li>
<p>什么是迭代器</p>
<ul>
<li>可以通过next函数取值的对象，就是迭代器</li>
</ul>
</li>
<li>
<p>迭代器协议</p>
<ul>
<li>迭代器协议是指对象能够使用next函数获取下一项数据，在没有下一项数据时触发一个 StopIteration 异常来终止迭代的约定</li>
</ul>
</li>
<li>
<p>迭代器协议的实现方法</p>
<ul>
<li>在类内需要用 <code>__next__(self)</code> 方法来实现迭代器协议</li>
</ul>
</li>
<li>
<p>迭代对象的语法形式</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>
        迭代器协议
        <span class="hljs-keyword">return</span> 数据
</div></code></pre>
</li>
<li>
<p>什么是可迭代对象</p>
<ul>
<li>是指能用iter(obj)函数返回迭代器的对象(实例)</li>
<li>可迭代对象内部要定义<code>__iter__(self)</code>方法来返回迭代器对象(实例)</li>
</ul>
</li>
<li>
<p>可迭代对象的语法形式</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterable</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
        语句块
        <span class="hljs-keyword">return</span> 迭代器
</div></code></pre>
</li>
<li>
<p>迭代器协议示例</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, iterable=<span class="hljs-params">()</span>)</span>:</span>
        self.data = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> iterable]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'MyList(%r)'</span> % self.data
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> MyListIterator(self.data)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListIterator</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, lst)</span>:</span>
        self.lst_data = lst  <span class="hljs-comment"># 绑定要迭代的列表　</span>
        self.cur_index = <span class="hljs-number">0</span>  <span class="hljs-comment"># 迭代的起始位置</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">if</span> self.cur_index &gt;= len(self.lst_data):
            <span class="hljs-keyword">raise</span> StopIteration  <span class="hljs-comment"># 发送迭代结束通知</span>
        r = self.lst_data[self.cur_index]
        self.cur_index += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> r  <span class="hljs-comment"># 返回此次提供的数据</span>

L = MyList(<span class="hljs-string">"ABCD"</span>)
print(L)  <span class="hljs-comment"># MyList(['A', 'B', 'C', 'D'])</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> L:
    print(x)  <span class="hljs-comment"># A B C D E</span>
</div></code></pre>
</li>
<li>
<p>练习：</p>
<ul>
<li>实现一个与系统内建的range类相同功能的类:<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRange</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, ...)</span>:</span>
        ...
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
        ...
<span class="hljs-comment"># 测试调用如下:</span>
L = list(MyRange(<span class="hljs-number">5</span>))
print(L)  <span class="hljs-comment"># [0, 1, 2, 3, 4]</span>
print(sum(MyRange(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>)))  <span class="hljs-comment"># 5050</span>
L2 = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> MyRange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>)]
print(L2)  <span class="hljs-comment"># [1, 16, 49]</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> MyR  ange(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>):
    print(x)<span class="hljs-comment"># 10, 7, 4, 1</span>
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>day20</p>
</li>
</ul>
<h2 id="%E5%BC%82%E5%B8%B8%E9%AB%98%E7%BA%A7">异常(高级)</h2>
<ul>
<li>异常回顾（可以用于异常的语句):
<ul>
<li>try-except   # 捕获异常,得到异常通知,并将程序从异常流程转为正常流程</li>
<li>try-finally  # 做任何流程(正常流程/异常流程)都必须要执行的语句</li>
<li>raise        # 发送异常通知并进入异常流程</li>
<li>assert       # 根据条件发送AssertionError类型的异常通知</li>
</ul>
</li>
</ul>
<h3 id="with-%E8%AF%AD%E5%8F%A5">with 语句</h3>
<ul>
<li>
<p>with 语句语法</p>
<pre class="hljs"><code><div><span class="hljs-keyword">with</span> 表达式<span class="hljs-number">1</span> [<span class="hljs-keyword">as</span> 变量<span class="hljs-number">1</span>], 表达式<span class="hljs-number">1</span> [<span class="hljs-keyword">as</span> 变量<span class="hljs-number">1</span>], ...:
    语句块
</div></code></pre>
</li>
<li>
<p>with 语句的作用</p>
<ul>
<li>使用于对资源进行访问的场合。确保使用过程中不管是否发生异常，都会执行必要的“清理”操作，并释放资源。
<ul>
<li>例如文件使用后自动关闭，线程中锁的自动获取和释放等(线程后面会学)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>with 语句 说明</p>
<ul>
<li>执行表达式,用as子句中的变量绑定生成的对象</li>
<li>with语句并不改变异常的状态</li>
</ul>
</li>
<li>
<p>with 语句示例</p>
<pre class="hljs"><code><div><span class="hljs-comment"># 用with 语句自动关闭文件</span>
<span class="hljs-keyword">with</span> open(<span class="hljs-string">"../day19.txt"</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> f:
        print(l)
        <span class="hljs-comment"># 以下为可能触发异常的语句</span>
        int(input(<span class="hljs-string">"请输入数字: "</span>))
        <span class="hljs-comment"># raise ZeroDivisionError</span>

print(<span class="hljs-string">"程序结束"</span>)
</div></code></pre>
</li>
<li>
<p>环境管理器</p>
<ul>
<li>类内有 <code>__enter__</code> 和 <code>__exit__</code> 实例方法的类被称为环境管理器</li>
<li>能够用with进行管理的对象必须是是环境管理器</li>
<li><code>__enter__</code> 将在进入with语句时被调用并返回 由as 变量 管理的对象</li>
<li><code>__exit__</code> 将在离开with语句时被调用,且可以用参数来判断在离开with语句时是否有异常发生并做出相应的处理</li>
</ul>
</li>
<li>
<p>最简单的环境管理器的代码编写示例</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-string">'''此类的对象可用于with语句进行管理'''</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>
        print(<span class="hljs-string">"已进入with语句"</span>)
        <span class="hljs-keyword">return</span> self

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_value, exc_taceback)</span>:</span>
        print(<span class="hljs-string">'已离开with语句'</span>)
        <span class="hljs-keyword">if</span> exc_type <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
            print(<span class="hljs-string">"with语句内没有发生异常！"</span>)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"with语句内有"</span>, exc_type, <span class="hljs-string">"类型的异常发生"</span>)

<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">with</span> A() <span class="hljs-keyword">as</span> a:
        print(<span class="hljs-string">"这是with语句内部的输出"</span>)
        int(input(<span class="hljs-string">"请输入整数: "</span>))
<span class="hljs-keyword">except</span> ValueError:
    print(<span class="hljs-string">"有ValueError类型的异常发生"</span>)
</div></code></pre>
</li>
</ul>
<h2 id="%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</h2>
<ul>
<li>
<p>运算符重载是指让自定义的类生成的对象(实例)能够使用运算符进行操作</p>
</li>
<li>
<p>运算符重载的作用</p>
<ul>
<li>让自定义类的实例像内建对象一样进行运算符操作</li>
<li>让程序简洁易读</li>
<li>对自定义对象将运算符赋予新的运算规则</li>
</ul>
</li>
<li>
<p>运算符重载说明：</p>
<ul>
<li>运算符重载方法的参数已经有固定的含义,不建议改变原有的意义</li>
</ul>
</li>
</ul>
<h3 id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">算术运算符重载</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__add__(self, rhs)</code></td>
<td style="text-align:center">self + rhs</td>
<td style="text-align:center">加法</td>
</tr>
<tr>
<td style="text-align:center"><code>__sub__(self, rhs)</code></td>
<td style="text-align:center">self - rhs</td>
<td style="text-align:center">减法</td>
</tr>
<tr>
<td style="text-align:center"><code>__mul__(self, rhs)</code></td>
<td style="text-align:center">self * rhs</td>
<td style="text-align:center">乘法</td>
</tr>
<tr>
<td style="text-align:center"><code>__truediv__(self, rhs)</code></td>
<td style="text-align:center">self / rhs</td>
<td style="text-align:center">除法</td>
</tr>
<tr>
<td style="text-align:center"><code>__floordiv__(self, rhs)</code></td>
<td style="text-align:center">self // rhs</td>
<td style="text-align:center">地板除</td>
</tr>
<tr>
<td style="text-align:center"><code>__mod__(self, rhs)</code></td>
<td style="text-align:center">self % rhs</td>
<td style="text-align:center">取模(求余)</td>
</tr>
<tr>
<td style="text-align:center"><code>__pow__(self, rhs)</code></td>
<td style="text-align:center">self ** rhs</td>
<td style="text-align:center">幂</td>
</tr>
</tbody>
</table>
<pre><code>rhs (right hand side) 右手边
</code></pre>
<ul>
<li>二元运算符重载方法格式:<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__xxx__</span><span class="hljs-params">(self, other)</span>:</span>
    ....
</div></code></pre>
</li>
<li>算术运算符重载示例<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNumber</span>:</span>
    <span class="hljs-string">"此类用于定义一个自定义的类，用于演示运算符重载"</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span>
        <span class="hljs-string">"构造函数,初始化MyNumber对象"</span>
        self.data = value
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">"转换为表达式字符串"</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyNumber(%d)"</span> % self.data
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add__</span><span class="hljs-params">(self, rhs)</span>:</span>
        <span class="hljs-string">"加号运算符重载"</span>
        print(<span class="hljs-string">"__add__ is called"</span>)
        <span class="hljs-keyword">return</span> MyNumber(self.data + rhs.data)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__sub__</span><span class="hljs-params">(self, rhs)</span>:</span>
        <span class="hljs-string">"减号运算符重载"</span>
        print(<span class="hljs-string">"__sub__ is called"</span>)
        <span class="hljs-keyword">return</span> MyNumber(self.data - rhs.data)

n1 = MyNumber(<span class="hljs-number">100</span>)
n2 = MyNumber(<span class="hljs-number">200</span>)
print(n1 + n2)
print(n1 - n2)
</div></code></pre>
</li>
</ul>
<h3 id="%E5%8F%8D%E5%90%91%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">反向算术运算符重载:</h3>
<ul>
<li>当运算符的左侧为内建类型时右侧为自定义类型进行算术运算符运算时，会出现TypeError错误</li>
<li>因无法修改内建类型的代码来实现运算符重载，此时需要使用反向算术运算符的重载来完成重载</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__radd__(self, lhs)</code></td>
<td style="text-align:center">lhs + self</td>
<td style="text-align:center">加法</td>
</tr>
<tr>
<td style="text-align:center"><code>__rsub__(self, lhs)</code></td>
<td style="text-align:center">lhs - self</td>
<td style="text-align:center">减法</td>
</tr>
<tr>
<td style="text-align:center"><code>__rmul__(self, lhs)</code></td>
<td style="text-align:center">lhs * self</td>
<td style="text-align:center">乘法</td>
</tr>
<tr>
<td style="text-align:center"><code>__rtruediv__(self, lhs)</code></td>
<td style="text-align:center">lhs / self</td>
<td style="text-align:center">除法</td>
</tr>
<tr>
<td style="text-align:center"><code>__rfloordiv__(self, lhs)</code></td>
<td style="text-align:center">lhs // self</td>
<td style="text-align:center">地板除</td>
</tr>
<tr>
<td style="text-align:center"><code>__rmod__(self, lhs)</code></td>
<td style="text-align:center">lhs % self</td>
<td style="text-align:center">取模(求余)</td>
</tr>
<tr>
<td style="text-align:center"><code>__rpow__(self, lhs)</code></td>
<td style="text-align:center">lhs ** self</td>
<td style="text-align:center">幂</td>
</tr>
</tbody>
</table>
<pre><code>lhs (left hand side) 左手边
</code></pre>
<h3 id="%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">复合赋值算术运算符重载:</h3>
<ul>
<li>以复合赋值算术运算符 x += y 为例，此运算符会优先调用 x.<strong>iadd</strong>(y)方法，如果没有__iadd__方法时会将复合赋值运算拆解为 x = x + y,然后调用 x = x.<strong>add</strong>(y)方法；如果再不存在__add__方法则会触发TypeError异常</li>
<li>其它复合赋值算术运算符也具有相同的规则</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和复合赋值语句</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__iadd__(self, rhs)</code></td>
<td style="text-align:center">self += rhs</td>
<td style="text-align:center">加法</td>
</tr>
<tr>
<td style="text-align:center"><code>__isub__(self, rhs)</code></td>
<td style="text-align:center">self -= rhs</td>
<td style="text-align:center">减法</td>
</tr>
<tr>
<td style="text-align:center"><code>__imul__(self, rhs)</code></td>
<td style="text-align:center">self *= rhs</td>
<td style="text-align:center">乘法</td>
</tr>
<tr>
<td style="text-align:center"><code>__itruediv__(self, rhs)</code></td>
<td style="text-align:center">self /= rhs</td>
<td style="text-align:center">除法</td>
</tr>
<tr>
<td style="text-align:center"><code>__ifloordiv__(self, rhs)</code></td>
<td style="text-align:center">self //= rhs</td>
<td style="text-align:center">地板除</td>
</tr>
<tr>
<td style="text-align:center"><code>__imod__(self, rhs)</code></td>
<td style="text-align:center">self %= rhs</td>
<td style="text-align:center">取模(求</td>
</tr>
<tr>
<td style="text-align:center"><code>__ipow__(self, rhs)</code></td>
<td style="text-align:center">self **= rhs</td>
<td style="text-align:center">幂</td>
</tr>
</tbody>
</table>
<h3 id="%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD">比较运算符的重载</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和复合赋值语句</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__lt__(self, rhs)</code></td>
<td style="text-align:center">self &lt;  rhs</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center"><code>__le__(self, rhs)</code></td>
<td style="text-align:center">self &lt;= rhs</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center"><code>__gt__(self, rhs)</code></td>
<td style="text-align:center">self &gt;  rhs</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center"><code>__ge__(self, rhs)</code></td>
<td style="text-align:center">self &gt;= rhs</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center"><code>__eq__(self, rhs)</code></td>
<td style="text-align:center">self == rhs</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center"><code>__ne__(self, rhs)</code></td>
<td style="text-align:center">self != rhs</td>
<td style="text-align:center">不等于</td>
</tr>
</tbody>
</table>
<ul>
<li>比较运算符通常返回布尔值 True 或 False</li>
</ul>
<h3 id="%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">位运算符重载</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__invert__(self)</code></td>
<td style="text-align:center">~ self</td>
<td style="text-align:center">取反(一元运算</td>
</tr>
<tr>
<td style="text-align:center"><code>__and__(self, rhs)</code></td>
<td style="text-align:center">self &amp;  rhs</td>
<td style="text-align:center">位与</td>
</tr>
<tr>
<td style="text-align:center"><code>__or__(self, rhs)</code></td>
<td style="text-align:center">self | rhs</td>
<td style="text-align:center">位或</td>
</tr>
<tr>
<td style="text-align:center"><code>__xor__(self, rhs)</code></td>
<td style="text-align:center">self ^  rhs</td>
<td style="text-align:center">位异或</td>
</tr>
<tr>
<td style="text-align:center"><code>__lshift__(self, rhs)</code></td>
<td style="text-align:center">self &lt;&lt; rhs</td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center"><code>__rshift__(self, rhs)</code></td>
<td style="text-align:center">self &gt;&gt; rhs</td>
<td style="text-align:center">右移</td>
</tr>
</tbody>
</table>
<h3 id="%E5%8F%8D%E5%90%91%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">反向位运算符重载</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__rand__(self, lhs)</code></td>
<td style="text-align:center">lhs &amp;  self</td>
<td style="text-align:center">位与</td>
</tr>
<tr>
<td style="text-align:center"><code>__ror__(self, lhs)</code></td>
<td style="text-align:center">lhs | self</td>
<td style="text-align:center">位或</td>
</tr>
<tr>
<td style="text-align:center"><code>__rxor__(self, lhs)</code></td>
<td style="text-align:center">lhs ^  self</td>
<td style="text-align:center">位异或</td>
</tr>
<tr>
<td style="text-align:center"><code>__rlshift__(self, lhs)</code></td>
<td style="text-align:center">lhs &lt;&lt; self</td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center"><code>__rrshift__(self, lhs)</code></td>
<td style="text-align:center">lhs &gt;&gt; self</td>
<td style="text-align:center">右移</td>
</tr>
</tbody>
</table>
<h3 id="%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">复合赋值位运算符重载</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和复合赋值语句</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__iand__(self, rhs)</code></td>
<td style="text-align:center">self &amp;=  rhs</td>
<td style="text-align:center">位与</td>
</tr>
<tr>
<td style="text-align:center"><code>__ior__(self, rhs)</code></td>
<td style="text-align:center">self |= rhs</td>
<td style="text-align:center">位或</td>
</tr>
<tr>
<td style="text-align:center"><code>__ixor__(self, rhs)</code></td>
<td style="text-align:center">self ^=  rhs</td>
<td style="text-align:center">位异或</td>
</tr>
<tr>
<td style="text-align:center"><code>__ilshift__(self, rhs)</code></td>
<td style="text-align:center">self &lt;&lt;= rhs</td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center"><code>__irshift__(self, rhs)</code></td>
<td style="text-align:center">self &gt;&gt;= rhs</td>
<td style="text-align:center">右移</td>
</tr>
</tbody>
</table>
<h3 id="%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">一元运算符重载</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__neg__(self)</code></td>
<td style="text-align:center">-self</td>
<td style="text-align:center">负号</td>
</tr>
<tr>
<td style="text-align:center"><code>__pos__(self)</code></td>
<td style="text-align:center">+self</td>
<td style="text-align:center">正号</td>
</tr>
<tr>
<td style="text-align:center"><code>__invert__(self)</code></td>
<td style="text-align:center">~self</td>
<td style="text-align:center">取反</td>
</tr>
</tbody>
</table>
<ul>
<li>一元运算符重载 语法：<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> 类名:</span> 
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__xxx__</span><span class="hljs-params">(self)</span>:</span>
        ....
</div></code></pre>
</li>
<li>一元运算符重载示例<pre class="hljs"><code><div><span class="hljs-comment"># 示例1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, iterable)</span>:</span>
         self.data = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> iterable]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'MyList(%r)'</span> % self.data
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__neg__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">'对自定义的列表取 -(负号)操作时，正变负，负变正'</span>
        <span class="hljs-keyword">return</span> MyList([-x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.data])
myl1 = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">5</span>])
myl2 = -myl1
print(myl2)
myl3 = +myl1
print(myl3)
</div></code></pre>
</li>
</ul>
<p>​</p>
<h3 id="innot-in-%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">in/not in 成员运算符重载</h3>
<ul>
<li>
<p><code>__contains__</code> 函数调用</p>
</li>
<li>
<p><code>__contains__</code> 函数格式</p>
<pre class="hljs"><code><div>def __contains__(self, e:'元素'):
    pass
</div></code></pre>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__contains__(self, e)</code></td>
<td style="text-align:center">e in self</td>
<td style="text-align:center">成员运算</td>
</tr>
</tbody>
</table>
<h3 id="%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">索引和切片运算符重载:</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">运算符和表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>__getitem__</code>(self, i)</td>
<td style="text-align:center">x = self[i]</td>
<td style="text-align:center">索引/切片取值</td>
</tr>
<tr>
<td style="text-align:center"><code>__setitem__</code>(self, i, val)</td>
<td style="text-align:center">self[i] = val</td>
<td style="text-align:center">索引/切片的赋值</td>
</tr>
<tr>
<td style="text-align:center"><code>__delitem__</code>(self, i)</td>
<td style="text-align:center">del self[i]</td>
<td style="text-align:center">del语句删除索引/切片</td>
</tr>
</tbody>
</table>
<ul>
<li>作用：
-让自定义类型的对象能够支持索引和切片操作</li>
</ul>
<h3 id="slice%E5%87%BD%E6%95%B0">slice函数</h3>
<ul>
<li>
<p>slice函数作用：</p>
<ul>
<li>用于创建一个slice切片对象,此对象存储一个切片的起始值，终止值，步长信息</li>
</ul>
</li>
<li>
<p>slice函数格式</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>slice(start=None, stop=None, step=None)</td>
<td>创建一个slice切片对象</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>slice 对象的属性</p>
<ul>
<li>s.start 切片的起始值，默认为None</li>
<li>s.stop 切片的终止值，默认为None</li>
<li>s.step 切片的步长，默认为None</li>
</ul>
</li>
<li>
<p>切片取值运算符重载</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, iterable)</span>:</span>
         self.data = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> iterable]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'MyList(%r)'</span> % self.data
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, i)</span>:</span>
        <span class="hljs-string">'[] 取值运算符重载'</span>
        <span class="hljs-keyword">if</span> type(i) <span class="hljs-keyword">is</span> slice:
            print(<span class="hljs-string">"正在进行切片取值操作..."</span>)
            print(<span class="hljs-string">"i.start ="</span>, i.start)
            print(<span class="hljs-string">"i.stop ="</span>, i.stop)
            print(<span class="hljs-string">"i.step ="</span>, i.step)
        <span class="hljs-keyword">return</span> MyList(self.data[i])


myl1 = MyList([<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-4</span>, <span class="hljs-number">5</span>])
print(myl1[::<span class="hljs-number">2</span>]) 
</div></code></pre>
</li>
</ul>
<h2 id="%E7%89%B9%E6%80%A7%E5%B1%9E%E6%80%A7-property">特性属性 @property</h2>
<ul>
<li>
<p>实现其它语言所拥有的 getter 和 setter功能</p>
</li>
<li>
<p>作用：</p>
<ul>
<li>用来模拟一个属性</li>
<li>通过@property装饰器可以对模拟属性赋值和取值加以控制</li>
</ul>
</li>
<li>
<p>特性属性示例</p>
<pre class="hljs"><code><div><span class="hljs-comment"># file : property.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, s)</span>:</span>
        self.__score = s
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getScore</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.__score
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setScore</span><span class="hljs-params">(self, a)</span>:</span>
        <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> a &gt; <span class="hljs-number">100</span>:
            print(<span class="hljs-string">"年龄超出了正常范围，请核对!"</span>)
        self.__score = a
    score = property(getScore, setScore)

s = Student(<span class="hljs-number">10</span>)
print(s.score)
</div></code></pre>
</li>
</ul>
<h2 id="pep8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">PEP8编码规范</h2>
<h3 id="%E4%BB%A3%E7%A0%81%E7%BC%96%E6%8E%92">代码编排</h3>
<ol>
<li>使用4空格缩进，不使用Tab,更不允许用Tab和空格混合缩进</li>
<li>每行最大长度最大79字节，超过部分使用反斜杠折行</li>
<li>类和全局函数定义间隔两个空行,类内方法定义间隔一个空行.其它地方可以不加空行。</li>
</ol>
<h3 id="%E6%96%87%E6%A1%A3%E7%BC%96%E6%8E%92">文档编排</h3>
<ol>
<li>其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。</li>
<li>不要在一句import中导入多个模块，比如不推荐import os, sys。</li>
<li>尽可能用import XX 而不采用from XX import YY引用库,因为可能出现名字冲突。</li>
</ol>
<h3 id="%E7%A9%BA%E6%A0%BC%E7%9A%84%E4%BD%BF%E7%94%A8">空格的使用</h3>
<ol>
<li>各种右括号前不用加空格</li>
<li>逗号、冒号、分号前不要加空格。</li>
<li>函数的左括号前不要加空格。如func(1)。</li>
<li>序列的左括号前不要加空格。如list[2]。</li>
<li>操作符左右各加一个空格，不要为了对齐增加空格。</li>
<li>函数默认参数使用的赋值符左右省略空格。</li>
<li>不要将多条语句写在同一行，尽管使用‘;’允许。</li>
<li>if/for/while语句中，即使执行语句只有一句，也必须另起一行</li>
</ol>
<h5 id="%E5%8E%9F%E5%88%99%EF%BC%9A%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E7%A9%BA%E6%A0%BC">原则：避免不必要的空格</h5>
<p>参考：<a href="https://www.douban.com/note/134971609/">https://www.douban.com/note/134971609/</a></p>
<p>以下内容可以参考<a href="http://www.cnblogs.com/MarchThree/p/4014775.html">http://www.cnblogs.com/MarchThree/p/4014775.html</a></p>

</body>
</html>
